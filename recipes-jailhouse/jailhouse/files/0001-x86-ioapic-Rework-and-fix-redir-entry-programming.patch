From bac03e4d5f5479933f1f5d0fbbc3f7aa6c4a0570 Mon Sep 17 00:00:00 2001
From: Jan Kiszka <jan.kiszka@siemens.com>
Date: Mon, 4 Nov 2019 09:10:13 +0100
Subject: [PATCH] x86: ioapic: Rework and fix redir entry programming

Currently, EOI of level-triggered IOAPIC interrupts may not work while
the related entry is masked - at least with QEMU as machine and
PREEMPT-RT as root cell. This is because we always overwrite trigger
mode and vector information when masking an entry.

Let's use that issue to rethink the programming pattern. The new one
works by still avoiding to map while masked but writing the entry with
an invalid remapping index. Furthermore, a redirection entry is only
updated in the IOAPIC on writes to the lower 32 bits. This is to ensure
its consistency. Writing higher bits happens first, either out of masked
state or with the identical value.

Signed-off-by: Jan Kiszka <jan.kiszka@siemens.com>
---
 hypervisor/arch/x86/ioapic.c | 69 +++++++++++++++++++++++---------------------
 1 file changed, 36 insertions(+), 33 deletions(-)

diff --git a/hypervisor/arch/x86/ioapic.c b/hypervisor/arch/x86/ioapic.c
index ee3b77f3..7b243097 100644
--- a/hypervisor/arch/x86/ioapic.c
+++ b/hypervisor/arch/x86/ioapic.c
@@ -114,49 +114,52 @@ static int ioapic_virt_redir_write(struct cell_ioapic *ioapic,
 	struct phys_ioapic *phys_ioapic = ioapic->phys_ioapic;
 	struct apic_irq_message irq_msg;
 	union ioapic_redir_entry entry;
-	int result;
+	int result = 0xffff;
 
 	entry = phys_ioapic->shadow_redir_table[pin];
 	entry.raw[reg & 1] = value;
 	phys_ioapic->shadow_redir_table[pin] = entry;
 
-	/* Do not map the interrupt while masked. */
-	if (entry.native.mask) {
-		/*
-		 * The mask is part of the lower 32 bits. Apply it when that
-		 * register half is written.
-		 */
-		if ((reg & 1) == 0)
-			ioapic_reg_write(phys_ioapic, reg, IOAPIC_REDIR_MASK);
-		return 0;
-	}
-
-	irq_msg = ioapic_translate_redir_entry(ioapic, pin, entry);
-
-	result = iommu_map_interrupt(ioapic->cell, (u16)ioapic->info->id, pin,
-				     irq_msg);
-	// HACK for QEMU
-	if (result == -ENOSYS) {
-		/* see regular update below, lazy version */
-		ioapic_reg_write(phys_ioapic, reg | 1, entry.raw[1]);
-		ioapic_reg_write(phys_ioapic, reg, entry.raw[reg & 1]);
-		return 0;
+	/*
+	 * Do not map the interrupt while masked. It may contain invalid state.
+	 * Rather write the invalid index 0xffff. That will not be used anyway
+	 * while the mask is set.
+	 */
+	if (!entry.native.mask) {
+		irq_msg = ioapic_translate_redir_entry(ioapic, pin, entry);
+
+		result = iommu_map_interrupt(ioapic->cell,
+					     (u16)ioapic->info->id, pin,
+					     irq_msg);
+		// HACK for QEMU
+		if (result == -ENOSYS) {
+			/* see regular update below, lazy version */
+			ioapic_reg_write(phys_ioapic, reg | 1, entry.raw[1]);
+			ioapic_reg_write(phys_ioapic, reg, entry.raw[reg & 1]);
+			return 0;
+		}
+		if (result < 0)
+			return result;
 	}
-	if (result < 0)
-		return result;
-
-	entry.remap.zero = 0;
-	entry.remap.int_index15 = result >> 15;
-	entry.remap.remapped = 1;
-	entry.remap.int_index = result;
 
 	/*
-	 * Upper 32 bits weren't written physically if the entry was masked so
-	 * far. Write them unconditionally when setting the lower bits.
+	 * Write all 64 bits on updates of the lower 32 bits to ensure the
+	 * consistency of an entry.
+	 *
+	 * The index information in the higher bits does not change when the
+	 * guest programs an entry, but they need to be initialized when taking
+	 * their ownership (always out of masked state, see
+	 * ioapic_prepare_handover).
 	 */
-	if ((reg & 1) == 0)
+	if ((reg & 1) == 0) {
+		entry.remap.zero = 0;
+		entry.remap.int_index15 = result >> 15;
+		entry.remap.remapped = 1;
+		entry.remap.int_index = result;
+
 		ioapic_reg_write(phys_ioapic, reg | 1, entry.raw[1]);
-	ioapic_reg_write(phys_ioapic, reg, entry.raw[reg & 1]);
+		ioapic_reg_write(phys_ioapic, reg, entry.raw[0]);
+	}
 
 	return 0;
 }
-- 
2.16.4

